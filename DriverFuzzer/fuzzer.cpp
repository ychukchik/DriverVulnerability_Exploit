#include <iostream>
#include <string>
#include <vector>
#include <random>
#include <Windows.h>

#define MAX_SIZE 2147483648

void Fuzzer();
void Mutation(std::string& data);
std::vector<unsigned char> generate_random_data(std::size_t size);

int main()
{
	Fuzzer();
}

void Mutation(std::string& data)
{
	using random_bytes_engine = std::independent_bits_engine<std::default_random_engine, CHAR_BIT, unsigned short>;
	int action = rand() % 5;
	int offset = 0, limit_value_offset = 0, number_of_iterations;
	char limit_values[] = { 0x00, 0xFF, 0xFFFF, 0xFF - 1, 0xFFFF - 1, 0xFFFFFFFF - 1 };

	switch (action)
	{
	case 0: // Создание случайного количества байт и добавление в конец имеющегося буфера
	{
		int number_of_bytes = rand() % 3000;
		std::vector<unsigned char> random_data = generate_random_data(number_of_bytes);
		data.insert(data.end() - 1, random_data.data(), random_data.data() + number_of_bytes);
		break;
	}
	case 1: // Увеличение буфера
	{
		if (data.size() < 2048)
		{
			data += data;
		}
		break;
	}
	case 2: // Подстановка граничного значения для переменных программы
	{
		number_of_iterations = rand() % 10;
		for (int i = 0; i < number_of_iterations; i++)
		{
			limit_value_offset = rand() % sizeof(limit_values);
			offset = rand() % 12;
			data[offset] = limit_values[limit_value_offset];
		}
		break;
	}
	case 3: // Подстановка рандомного значения для переменных программы
	{
		number_of_iterations = rand() % 10;
		for (int i = 0; i < number_of_iterations; i++)
		{
			limit_value_offset = rand() % sizeof(limit_values);
			offset = rand() % 12;
			data[offset] = rand();
		}
		break;
	}
	case 4: // Стирание данных из конца файла
	{
		offset = rand() % data.size();
		int erase_size = rand() % (data.size() - offset);
		data.erase(data.begin() + offset, data.begin() + offset + erase_size);
		break;
	}
	}

	if (data.size() < 2048)
	{
		data += data;
	}
}

// Генератор псевдослучайных чисел
std::vector<unsigned char> generate_random_data(std::size_t size)
{
	std::random_device rd;
	std::mt19937 gen(rd());
	std::uniform_int_distribution<> dis(1, 255);

	std::vector<unsigned char> data(size);
	for (std::size_t i = 0; i < size; ++i) {
		data[i] = static_cast<unsigned char>(dis(gen));
	}
	return data;
}

void Fuzzer()
{
	srand((unsigned)time(0));
	std::string buffer = "qwertyUIOP1234567890!@#$%^&*()asdfgHJKLz";
	char info[256] = { 0 };
	int attempts = 0;

	HANDLE hDriver = CreateFile(L"\\\\.\\HackSysExtremeVulnerableDriver_mbks", GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED, NULL);
	if (hDriver == INVALID_HANDLE_VALUE)
	{
		printf("Failed to get device handle: 0x%X\r\n", GetLastError());
		return;
	}

	DWORD BytesReturned = 0x00000000;
	DWORD IoControlCode = 0x222403;
	while (1)
	{
		Mutation(buffer);
		DeviceIoControl(hDriver, (DWORD)IoControlCode, (LPVOID)buffer.c_str(), buffer.size(), NULL, 0, &BytesReturned, NULL);
		attempts += 1;
		snprintf(info, 256, "\rAttempts: %d", attempts);
		std::cout << info;
	}
}